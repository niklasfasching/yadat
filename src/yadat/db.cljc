(ns yadat.db
  (:require [clojure.set :as set]))

(defprotocol Db
  "A database for datoms."
  (is? [db a x]
    "Checks whether the schema of `db` defines attribute `a` to be a `x`.
     `x` can be one of:
     - :many
     - :unique-identity
     - :unique-value
     - :reference
     - :component")
  (new-eid [db]
    "Returns [`db` eid], eid being a new, unique eid.")
  (update-eid [db eid]
    "Returns `db` with eid state updated to reflect `eid`.
     To ensure that `new-eid` generates new & unique eids, eids not generated by
     `new-eid` possibly have to be taken into account. This function is called
     with all such external eids.")
  (insert [db datom]
    "Returns `db` with `datom` added.")
  (delete [db datom]
    "Returns `db` with `datom` removed.")
  (select [db datom]
    "Returns collection of datoms matching `datom` from `db`.")
  (serialize [db]
    "Returns edn serialized representation of `db`."))

(defmulti open
  "Returns an empty db of type `t` implementing the `Db` protocol."
  (fn [t schema] t))

(defmulti deserialize
  "Returns of type `t` deserialized from input `edn` string. See `serialize`."
  (fn [t edn] t))

(defn real-eid? [db x] (and (number? x) (pos? x)))

(defn temp-eid? [db x] (and (number? x) (neg? x)))

(defn lookup-ref? [db x]
  (when-let [[a v] (and (vector? x) (= 2 (count x)) x)]
    (and (keyword? a)
         (some? v)
         (or (is? db a :unique-identity)
             (is? db a :unique-value)))))

(defn eid? [db x]
  (or (real-eid? db x)
      (temp-eid? db x)
      (lookup-ref? db x)))

(defn resolve-lookup-ref-eid
  "Resolve lookup-ref into an eid via `db` lookup. Throws if lookup fails."
  [{:keys [db] :as transaction} [a v :as lookup-ref]]
  (if-not (or (is? db a :unique-value) (is? db a :unique-identity))
    (throw (ex-info "Invalid lookup-ref: !unique" {:lookup-ref lookup-ref})))
  (if-let [[eid _ _] (first (select db [nil a v]))]
    [transaction eid]
    (throw (ex-info "Invalid lookup-ref" {:lookup-ref lookup-ref}))))

(defn resolve-temp-eid
  "Resolve temp-eid to real-eid using `temp-eids`.
  Returns real-eid from the `temp-eids` map of the transaction if one exists,
  otherwise sets it."
  [{:keys [db temp-eids] :as transaction} temp-eid]
  (if-let [eid (get temp-eids temp-eid)]
    [transaction eid]
    (let [[db eid] (new-eid db)
          temp-eids (assoc temp-eids temp-eid eid)
          transaction (assoc transaction :db db :temp-eids temp-eids)]
      [transaction eid])))

(defn resolve-eid
  "Resolves `raw-eid` to a real eid. Returns [transaction eid].
  `raw-eid` can be one of #{lookup-ref temp-eid real-eid}. Returns a new eid if
  `raw-eid` is not one of the above eid-types.
  If `avs` is provided, additionally considers unique attributes in resolution."
  ([{:keys [db] :as transaction} raw-eid]
   (cond
     (real-eid? db raw-eid) [transaction raw-eid]
     (temp-eid? db raw-eid) (resolve-temp-eid transaction raw-eid)
     (lookup-ref? db raw-eid) (resolve-lookup-ref-eid transaction raw-eid)
     :else (let [[db eid] (new-eid db)
                 transaction (assoc transaction :db db)]
             [transaction eid])))
  ([{:keys [db] :as transaction} avs raw-eid]
   (let [[transaction resolved-eid] (resolve-eid transaction raw-eid)
         eid (reduce (fn [resolved-eid [a v]]
                       (if (or (is? db a :unique-identity)
                               (is? db a :unique-value))
                         (let [[existing-eid _ _] (first (select db [nil a v]))]
                           (if (or (nil? raw-eid) (nil? existing-eid)
                                   (= resolved-eid existing-eid))
                             (or existing-eid resolved-eid)
                             (throw (ex-info "Entity id conflict"
                                             {:eid1 existing-eid
                                              :eid2 resolved-eid
                                              :a a :v v}))))
                         resolved-eid)) resolved-eid avs)]
     [transaction eid])))

(defn reverse-ref? [a]
  (and (keyword? a) (= (first (name a)) \_)))

(defn reversed-ref [a]
  (if (reverse-ref? a)
    (keyword (namespace a) (subs (name a) 1))
    (keyword (namespace a) (str "_" (name a)))))

(defn datom [db e a v]
  (cond
    (and (not (is? db a :reference))
         (reverse-ref? a)) (throw (ex-info "Invalid reverse reference" {:a a}))
    (reverse-ref? a) [v (reversed-ref a) e]
    :else [e a v]))

(defn retract-datom [db datom]
  (-> (delete db (first (select db datom)))))

(defn add-datom [db [eid a v :as datom]]
  (if (is? db a :many)
    (insert db datom)
    (insert (retract-datom db [eid a]) datom)))

(defn store-entity
  "Store entity of `db-id` and `avs` in `db`. Returns [transaction eid].
  The eid can be one of the following:
  1. nil if `avs` is empty
  2. the eid resolved from the passed in `db-id` & `avs` (:db.unique)
  3. a newly assigned eid"
  [transaction db-id avs]
  (let [empty-entity? (empty? avs)
        [transaction eid] (resolve-eid transaction avs db-id)]
    (loop [db (:db transaction)
           [[a v] & avs] avs]
      (cond
        empty-entity? [transaction nil]
        (and (nil? a) (nil? avs)) [(assoc transaction :db db) eid]
        :else (recur (add-datom db (datom db eid a v)) avs)))))

(defn add-entity
  "Add entity `e` to the `db` of `transaction`. Returns [transaction eid].
  Nested entities (fields marked as references) are resolved depth first.
  This is necessary as the eid of the entity can depend on the value of
  reference fields marked as unique."
  [transaction e]
  (let [eid (:db/id e)
        t (if (number? eid)
            (update-in transaction [:db] update-eid eid)
            transaction)]
    (loop [{:keys [db] :as t} t
           [[a v] & raw-avs] (seq (dissoc e :db/id))
           avs []]
      (cond
        (and (nil? raw-avs) (nil? a)) (store-entity t eid avs)
        (and (is? db a :many)
             (not (lookup-ref? db v))
             (sequential? v)) (recur t (concat (for [v v] [a v]) raw-avs) avs)
        (and (is? db a :reference)
             (eid? db v)) (let [[t v] (resolve-eid t v)]
                            (recur t raw-avs (conj avs [a v])))
        (is? db a :reference) (let [[t v] (add-entity t v)]
                                (recur t raw-avs (conj avs [a v])))
        :else (recur t raw-avs (conj avs [a v]))))))

(defn transact
  "Add `entities` to the `db`. Returns [transaction eids].
  transaction is a map containing db & temp-eids - temp-eids
  being a map of [temp-eid real-eid].
  eids are the ids of the `entities` in the `db` - be they newly added or
  existing entities that were updated."
  [db entities]
  (loop [transaction {:db db :temp-eids {}}
         [e & es] entities
         eids #{}]
    (cond
      (and (nil? e) (nil? es)) [transaction eids]
      (map? e) (let [[transaction eid] (add-entity transaction e)]
                 (recur transaction es (conj eids eid)))
      (sequential? e) (let [[op eid a v] e
                            datom (datom db eid a v)
                            f (fn [db] (case op
                                         :db/add (add-datom db datom)
                                         :db/retract (retract-datom db datom)))
                            transaction (update-in transaction [:db] f)]
                        (recur transaction es (conj eids eid))))))
