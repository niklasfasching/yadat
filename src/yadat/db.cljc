(ns yadat.db
  (:require [yadat.schema :as schema]))

(defrecord Datom [e a v])

(defprotocol Db
  (is? [db a x]
    "Checks whether the schema of `db` defines attribute `a` to be a `x`.
  See `schema/is?`.")
  (new-eid [db]
    "Returns [`db` eid], eid being a new, unique eid.")
  (update-eid [db eid]
    "Returns `db` with eid state updated to reflect `eid`.
   To ensure that `new-eid` generates new & unique eids, eids not generated by
   `new-eid` possibly have to be taken into account. This function is called
   with all such external eids.")
  (insert [db datom]
    "Returns `db` with `datom` added.")
  (delete [db datom]
    "Returns `db` with `datom` removed.")
  (select [db datom]
    "Returns sequence of datoms matching `datom` from `db`.
  A nil value for a field of the datom matches any other value for that field.")
  (serialize [db]
    "Returns the serialized (tagged) representation of `db`.
  Note that deserialization requires a data-reader to be registered for the
  corresponding tagged literal. See `*data-readers*` and `data-readers.cljc`."))

(defmulti create
  "Returns an empty db of type `t` implementing the `Db` protocol."
  (fn [t schema] t))

(defn datom [e a v]
  (if (schema/reverse-ref? a)
    (->Datom v (schema/reversed-ref a) e)
    (->Datom e a v)))

(defmacro datom-comparator
  "Create a comparator fn that compares datoms in order of `fields` using `cmp`.
  Example: (def eav-datom-comparator (datom-comparator compare e a v))"
  [cmp & fields]
  (let [datom1 (with-meta (gensym) {:tag 'yadat.db.Datom})
        datom2 (with-meta (gensym) {:tag 'yadat.db.Datom})
        field-accessors (map #(symbol (str ".-" %)) (reverse fields))
        body (reduce (fn [previous-result f]
                       `(let [result# (~cmp (~f ~datom1) (~f ~datom2))]
                          (if (= result# 0)
                            ~previous-result
                            result#)))
                     0 field-accessors)]
    `(fn [~datom1 ~datom2] ~body)))

(defn retract-datom [transaction eid a v]
  (let [datom (datom eid a v)]
    (-> transaction
        (update-in [:db-after] (fn [db] (delete db (first (select db datom)))))
        (update-in [:tx-data] conj (assoc datom :add false)))))

(defn add-datom [{db :db-after :as transaction} eid a v]
  (let [datom (datom eid a v)]
    (-> (if (is? db a :many)
          transaction
          (retract-datom transaction eid a nil))
        (update-in [:db-after] insert datom)
        (update-in [:tx-data] conj (assoc datom :add true)))))

(defn real-eid? [db x]
  (and (number? x) (pos? x)))

(defn temp-eid? [db x]
  (and (number? x) (neg? x)))

(defn lookup-ref? [db x]
  (when-let [[a v] (and (vector? x) (= 2 (count x)) x)]
    (and (keyword? a)
         (some? v)
         (is? db a :unique))))

(defn eid? [db x]
  (or (real-eid? db x)
      (temp-eid? db x)
      (lookup-ref? db x)))

(defn lookup-ref-eid [db [a v :as lookup-ref]]
  (if-not (is? db a :unique)
    (throw (ex-info "Invalid lookup-ref: Attribute must be marked as unique."
                    {:lookup-ref lookup-ref})))
  (if-let [datom ^Datom (first (select db (datom nil a v)))]
    (.-e datom)
    (throw (ex-info "Invalid lookup-ref. No matching entity found in db."
                    {:lookup-ref lookup-ref}))))

(defn resolve-lookup-ref-eid
  "Resolve lookup-ref into an eid via `db` lookup. Throws if lookup fails."
  [{db :db-after :as transaction} lookup-ref]
  [transaction (lookup-ref-eid db lookup-ref)])

(defn resolve-temp-eid
  "Resolve temp-eid to a real eid using `temp-eids`.
  Returns a real eid from the `temp-eids` map of the transaction if one exists,
  otherwise assigns and returns a new real eid for that temp-eid."
  [{:keys [db-after temp-eids] :as transaction} temp-eid]
  (if-let [eid (get temp-eids temp-eid)]
    [transaction eid]
    (let [[db-after eid] (new-eid db-after)
          temp-eids (assoc temp-eids temp-eid eid)]
      [(assoc transaction :db-after db-after :temp-eids temp-eids) eid])))

(defn resolve-eid
  "Resolves `raw-eid` to a real eid. Returns [transaction eid].
  `raw-eid` can be one of #{lookup-ref temp-eid real-eid}. Assigns and returns a
  new eid if `raw-eid` is not one of the above eid types.
  If `avs` is provided, additionally considers the unique attributes in
  resolution of the eid."
  ([{db :db-after :as transaction} raw-eid]
   (cond
     (real-eid? db raw-eid) [transaction raw-eid]
     (temp-eid? db raw-eid) (resolve-temp-eid transaction raw-eid)
     (lookup-ref? db raw-eid) (resolve-lookup-ref-eid transaction raw-eid)
     :else (let [[db eid] (new-eid db)
                 transaction (assoc transaction :db-after db)]
             [transaction eid])))
  ([{db :db-after :as transaction} raw-eid avs]
   (let [[transaction resolved-eid] (resolve-eid transaction raw-eid)
         eid (reduce (fn [resolved-eid [a v]]
                       (if (is? db a :unique)
                         (let [datom ^Datom (first (select db (datom nil a v)))
                               existing-eid (and datom (.-e datom))]
                           (if (or (nil? raw-eid) (nil? datom)
                                   (= resolved-eid existing-eid))
                             (or existing-eid resolved-eid)
                             (throw (ex-info "Entity id conflict"
                                             {:eid1 existing-eid
                                              :eid2 resolved-eid
                                              :a a :v v}))))
                         resolved-eid))
                     resolved-eid avs)]
     [transaction eid])))

(defn maybe-update-eid [transaction eid]
  (if (real-eid? (:db-after transaction) eid)
    (update-in transaction [:db-after] update-eid eid)
    transaction))

(defn store-entity
  "Store entity of `db-id` & `avs` in `transaction`. Returns [transaction eid].
  The returned eid can be one of the following:
  - nil if `avs` is empty
  - the eid resolved from the passed in `db-id` & `avs` (~ :unique attributes)
  - a newly assigned eid"
  [transaction db-id avs]
  (let [[transaction eid] (resolve-eid transaction db-id avs)
        eid (if (empty? avs) nil eid)
        transaction (reduce (fn [transaction [a v]]
                              (add-datom transaction eid a v))
                            transaction avs)]
    [transaction eid]))

(defn add-entity
  "Add `entity` map to `transaction`. Returns [transaction eid].
  Nested entities (~ :reference attributes) are resolved depth first.
  Depth first traversal is necessary as the eid of an entity can depend on the
  value of reference attributes marked as unique and thus have to be resolved
  before we can figure out the eid of the parent entity and store it."
  [transaction {:keys [:db/id] :as entity}]
  (loop [{db :db-after :as t} (maybe-update-eid transaction id)
         [[a v] & raw-avs :as unresolved-avs] (dissoc entity :db/id)
         resolved-avs []]
    (cond
      ;; all av pairs have been resolved: store entity and return
      (empty? unresolved-avs)
      (store-entity t id resolved-avs)

      ;; :many attribute with multiple values:
      ;; flatten into separate av pairs and try processing them again
      (and (is? db a :many) (sequential? v) (not (lookup-ref? db v)))
      (recur t (concat (for [v v] [a v]) raw-avs) resolved-avs)

      ;; :reference attribute with entity as value:
      ;; resolve nested entity and add with eid to resolved av pairs
      (and (is? db a :reference) (not (eid? db v)))
      (let [[t eid] (add-entity t v)]
        (if eid
          (recur t raw-avs (conj resolved-avs [a eid]))
          (recur t raw-avs resolved-avs)))

      ;; :reference attribute with (possibly raw) eid as value:
      ;; resolve eid & add to resolved av pairs
      (is? db a :reference)
      (let [[t v] (resolve-eid t v)]
        (recur t raw-avs (conj resolved-avs [a v])))

      ;; normal / processed av pair: move to resolved av pairs
      :else
      (recur t raw-avs (conj resolved-avs [a v])))))

(defn execute-operation
  "Execute operation `op` against :db-after of `transaction`.
  The following operations are supported
  - :db/add - add datom to db
  - :db/retract - retract datom from db"
  [transaction [op eid a v]]
  (let [transaction (maybe-update-eid transaction eid)
        [transaction eid] (resolve-eid transaction eid)]
    (case op
      :db/add (add-datom transaction eid a v)
      :db/retract (retract-datom transaction eid a v))))

(defn transact
  "Add `entities` to `db`. Returns transaction.
  An entity can be:
  - map: insert (possibly multiple) attributes for an eid
  - sequential: execute operation [op eid a v]
  - nil: skipped

  A transaction is defined as follows:
  - :temp-eids is a map of temp-eid -> eid.
  - :tx-data is a vector of all datoms added and retracted in the transaction
    The datom format is [eid a v added?], added? being a boolean.
  - :db-after is the modified db
  - :db-before is a snapshot of the db before the transaction."
  [db entities]
  (let [transaction {:db-before db :db-after db :temp-eids {} :tx-data []}]
    (reduce
     (fn [transaction e]
       (cond
         (map? e) (let [[transaction _] (add-entity transaction e)] transaction)
         (sequential? e) (execute-operation transaction e)
         (nil? e) transaction
         :else (throw (ex-info "Invalid entity" {:e e}))))
     transaction entities)))
